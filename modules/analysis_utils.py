import subprocess
import os, sys
import uuid
import typing as t
from typing import Optional
from pathlib import Path
from Bio import SeqIO
import modules.database_utils as db_utils
from modules.genome_utils import CasContig
from dataclasses import dataclass





@dataclass
class ArrayCandidate:
    """
    Class to represent a candidate CRISPR array.
    
    Attributes:
        instance_id (str): Unique identifier for the instance.
        biosample_accn (str): The biosample accession number.
        array_id (str): Unique identifier for the CRISPR array.
        arry_start (int): Start position of the CRISPR array in the genome.
        arry_end (int): End position of the CRISPR array in the genome.
        strand (str): Strand orientation of the CRISPR array (Forward or Reversed).
        length (int): Length of the CRISPR array.
        avg_repeat_length (int): Average length of direct repeats in the CRISPR array.
        avg_spacer_length (int): Average length of spacers in the CRISPR array.
        num_spacers (int): Number of spacers in the CRISPR array.
        orientation (str): Orientation of the CRISPR array.
        category (str): Category of the CRISPR array.
        score (int): Score assigned to the CRISPR array based on certain criteria.
        filter (str): Filter status of the CRISPR array (e.g., PASSED or FAILED).
        spacerseq (List[str]): List of spacer sequences associated with the CRISPR array.
        drseq (List[str]): List of direct repeat sequences associated with the CRISPR array.
    
    Returns:
        ArrayCandidate: An instance of ArrayCandidate containing the CRISPR array information.
    """

    instance_id: Optional[str] = None
    biosample_accn: Optional[str] = None
    name: Optional[str] = None
    array_id: Optional[str] = None
    arry_start: Optional[int] = None
    arry_end: Optional[int] = None
    strand: Optional[str] = None
    length: Optional[int] = None
    avg_repeat_length: Optional[int] = None
    avg_spacer_length: Optional[int] = None
    num_spacers: Optional[int] = None
    dist_to_cas: Optional[int] = None
    orientation: Optional[str] = None
    category: Optional[str] = None
    score: Optional[float] = None
    filter: Optional[str] = None
    spacerseq: t.List[str] = None
    drseq: t.List[str] = None


    @staticmethod
    def get_instance_id() -> str:
        """
        Generate a unique instance ID for the ArrayCandidate.
        
        Returns:
            str: A unique identifier for the instance.
        """
        return str(uuid.uuid4())
    


    @staticmethod
    def strand_to_str(strand: str) -> str:
        """
        Convert strand information to a string representation.
        
        Args:
            strand (str): The strand information, either 'Forward' or 'Reversed'.
        
        Returns:
            str: 'F' for Forward, 'R' for Reversed.
        """
        if strand == "Forward":
            return "Foward"
        elif strand == "Reversed":
            return "Reverse"
        else:
            return "Unknown"


    @classmethod
    def read_summary_file(cls, summary_file: Path) -> t.Optional[t.List['ArrayCandidate']]:
        """
        Read the summary file generated by CRISPRidentify and create instances of ArrayCandidate.
        
        This method reads the summary file and creates instances of ArrayCandidate for each CRISPR array found.
        
        Args:
            summary_file (Path): The path to the summary file generated by CRISPRidentify.
        
        Returns:
            List[ArrayCandidate]: A list of ArrayCandidate instances if successful, None otherwise.
        """
        if not summary_file.exists():
            print(f"Summary file {summary_file} does not exist.", file=sys.stderr)
            return None
    
        df_summary = db_utils.read_table_from_db(summary_file)
        return df_summary


    @classmethod
    def get_cas_contig(cls, gbff: Path, gff: Path) -> t.Optional['CasContig']:
        """
        Retrieve the CasContig object for a given biosample accession number.
        
        This method queries the database to find the CasContig associated with the given biosample accession number.
        
        Args:
            biosample_accn (str): The biosample accession number.
            gbff (Path): Path to the GenBank file.
            gff (Path): Path to the GFF file.
            storage (Path): Path to the storage directory.
        
        Returns:
            CasContig: An instance of CasContig if found, None otherwise.
        """
    
        cls = CasContig.get_cas_info(gbff, gff)

        return cls



    @classmethod
    def calc_dist_to_cas(cls, cascontig: 'CasContig', arry_start: int, arry_end: int) -> int:
        """        
        Calculate the distance from the CRISPR array to the nearest Cas gene.
        
        Args:
            cascontig (CasContig): The CasContig object containing information about the Cas gene.
            arry_start (int): Start position of the CRISPR array.
            arry_end (int): End position of the CRISPR array.
        
        Returns:
            int: The distance to the nearest Cas gene.
        """

        cas_start = cascontig.start
        cas_end = cascontig.end

        # Normalize cas coordinates in case of reverse orientation
        if cas_start > cas_end:
            cas_start, cas_end = cas_end, cas_start

        # General overlap condition
        if arry_end >= cas_start and arry_start <= cas_end:
            return 0

        # Array is before Cas gene
        elif arry_end < cas_start:
            return cas_start - arry_end

        # Array is after Cas gene
        else:  # arry_start > cas_end
            return arry_start - cas_end        


    @classmethod
    def complie_crispr_arrays(cls, result_folder: Path, gbff: Path, gff: Path, storage: Path) -> t.Optional[t.List['ArrayCandidate']]:
        """
        Gather summary of CRISPR arrays from the output of CRISPRidentify.
        
        This method reads the summary file generated by CRISPRidentify and creates instances of ArrayCandidate
        for each CRISPR array found in the genome. It returns a list of these instances.
        
        Args:
            analysis_folder (Path): The path to the result output folder from CRISPRidentify.
        
        Returns:
            List[ArrayCandidate]: A list of ArrayCandidate instances if successful, None otherwise.
        """

        
        # Check if the output folder was created
        if result_folder.exists():
            bioaccession = result_folder.name.split("_")[0]
            # Read the summary file into a DataFrame
            summary_file = result_folder / "Summary.csv"
            summary_df = cls.read_summary_file(summary_file)
            instances = []
            cascontig = cls.get_cas_contig(gbff, gff)
            for index, row in summary_df.iterrows():
                # Create an ArrayCandidate instance for each CRISPR array found
                cls_instance = cls(
                    instance_id=cls.get_instance_id(),
                    biosample_accn=bioaccession,
                    array_id=f"{row['ID']}",
                    arry_start=row['Start'],
                    arry_end=row['End'],
                    strand=row['Strand'],
                    length=row['Length'],
                    avg_repeat_length=row['Repeat Length'],
                    avg_spacer_length=row['Average Spacer Length'],
                    num_spacers=row['Number of spacers'],
                    dist_to_cas=cls.calc_dist_to_cas(cascontig, row['Start'], row['End']),
                    orientation=cls.strand_to_str(row['Strand']),
                    category=row['Category'],
                    score=row['Score']
                )
                instances.append(cls_instance)

        # If the result folder does not exist, check the parent directory
        elif not result_folder.exists():
            result_folder = result_folder.parent
            bioaccession =   os.path.basename(result_folder).split("_")[0]
            summary_file = summary_file = result_folder / "Complete_summary.csv"
            summary_df = cls.read_summary_file(summary_file)
            instances = []
            cascontig = cls.get_cas_contig(gbff, gff)
            contig_id = str(cascontig.contig_id).split(".")[0]
            # subselect only rows that match the contig_id
            summary_df = summary_df[summary_df['Name'].str.startswith(contig_id)]
            
            for index, row in summary_df.iterrows():
                # Create an ArrayCandidate instance for each CRISPR array found
                cls_instance = cls(
                    instance_id=cls.get_instance_id(),
                    biosample_accn=bioaccession,
                    name=row['Name'],
                    array_id=f"{row['ID']}",
                    arry_start=row['Start'],
                    arry_end=row['End'],
                    strand=row['Strand'],
                    length=row['Length'],
                    avg_repeat_length=row['Repeat Length'],
                    avg_spacer_length=row['Average Spacer Length'],
                    num_spacers=row['Number of spacers'],
                    dist_to_cas=cls.calc_dist_to_cas(cascontig, row['Start'], row['End']),
                    orientation=cls.strand_to_str(row['Strand']),
                    category=row['Category'],
                    score=row['Score']
                )
                instances.append(cls_instance)
            
            if not result_folder.exists():
                print(f"Result folder {result_folder} does not exist. CRISPRidentify may not have run successfully.", file=sys.stderr)
                return None

        return instances


    @classmethod
    def is_within_len_range(cls, avg_len: int) -> bool:
        return avg_len - 2  <= avg_len <= avg_len + 2



    @classmethod
    def filter_candidates(
        cls, 
        candidates: t.List['ArrayCandidate'], 
        avg_dr_len, 
        avg_spacer_len, 
        min_spacers: int = 3, 
        dist_to_cas: int = 20000
        ) -> t.List['ArrayCandidate']:
        """
        Filter the list of ArrayCandidate instances based on minimum number of spacers and minimum length.
        
        Args:
            candidates (List[ArrayCandidate]): List of ArrayCandidate instances to filter.
            min_spacers (int): Minimum number of spacers required for a candidate to be considered valid.
            min_length (int): Minimum length required for a candidate to be considered valid.
        
        Returns:
            List[ArrayCandidate]: Filtered list of ArrayCandidate instances.
        """

        for c in candidates:
            passed = (
                c.num_spacers >= min_spacers and
                c.dist_to_cas < dist_to_cas and
                cls.is_within_len_range(c.avg_spacer_length) and
                cls.is_within_len_range(c.avg_repeat_length)
            )
            c.filter = "PASSED" if passed else "FAILED"
        return candidates


    @classmethod
    def read_fasta_file(cls, contig_id: str, fasta_file: Path) -> t.List[str]:
        """
        Read a FASTA file and return a list of sequences.
        
        Args:            
            fasta_file (Path): Path to the FASTA file containing spacer sequences.
        
        Returns:
            List[str]: List of spacer sequences read from the FASTA file.
        """
        if not fasta_file.exists():
            print(f"FASTA file {fasta_file} does not exist.", file=sys.stderr)
            return []

        sequences = []
        for record in SeqIO.parse(fasta_file, "fasta"):
            if record.id.startswith(contig_id):
                sequences.append(str(record.seq))
        return sequences        


    @classmethod
    def get_spacer_dr_seq(cls, candidate: 'ArrayCandidate', result_folder: Path):
        """
        Get the list of spacer sequences.

        Args:
            candidate (ArrayCandidate): An instance of ArrayCandidate containing the CRISPR array information.
            result_folder (Path): Path to the result output folder from CRISPRidentify.

        Returns:
            List[str]: List of spacer sequences.
        """

        # Check if the output folder was created
        if result_folder.exists():            
            # Get spacer sequences
            spacer_fasta = result_folder / "Spacers.fasta"
            contig_id = f"CRISPR_{candidate.array_id}_"
            spacerseq = cls.read_fasta_file(contig_id, spacer_fasta)
            candidate.spacerseq = spacerseq

            # Get direct repeat sequences
            dr_fasta = result_folder / "Repeats.fasta"
            contig_id = f"CRISPR_{candidate.array_id}_"
            drseq = cls.read_fasta_file(contig_id, dr_fasta)
            candidate.drseq = drseq

            return candidate

        # If the result folder does not exist, check the parent directory
        elif not result_folder.exists():
            result_folder = result_folder.parent

            # Get spacer sequences
            spacer_fasta = result_folder / "Complete_spacer_dataset.fasta"
            contig_id = f"{candidate.name}_CRISPR_{candidate.array_id}_"
            spacerseq = cls.read_fasta_file(contig_id, spacer_fasta)
            candidate.spacerseq = spacerseq
            
            # Get direct repeat sequences
            dr_fasta = result_folder / "Complete_repeat_dataset.fasta"
            contig_id = f"{candidate.name}_CRISPR_{candidate.array_id}_"
            drseq = cls.read_fasta_file(contig_id, dr_fasta)
            candidate.drseq = drseq

            return candidate
            
        if not result_folder.exists():
            print(f"Result folder {result_folder} does not exist. CRISPRidentify may not have run successfully.", file=sys.stderr)
            return None

        